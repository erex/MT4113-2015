#I hereby confirm that the attached is my own work, except where clearly indicated in the text.

###MT4113: Computing in Statistics, Assignment 1

## ---------------- Algorithm for normally distributed deviates ----------------
my.rnorm <- function(n, mean=0, sd=1){
##Purpose: Generate random normal numbers 
##Inputs: std as the standarddeviation of the distribution, m as the mean of the distribution and n as the amount of numbers to return
##Outputs: vector of n random normally distributed numbers (distributed with std and m)
  #For odd numbers the next even number of normal distributed values is created and the vector is trimmed in the end  
  if(n%%2!=0){
    n_new <- n+1
  } else {n_new<-n}
  #Checking for plausibility of arguments:  
  if(missing(n)){stop("invalid arguments")}
  if(is.complex(n) | is.complex(sd) | is.complex(mean)){stop("invalid arguments")}
  if(!is.numeric(sd) | !is.numeric(mean) | !is.numeric(n)){stop("invalid arguments")}
  if(sd<0){stop("invalid arguments")}
  #if(sd == 0){warning("A standard deviation of 0 results in all values being equal")}
  if(n<=0){stop("invalid arguments")}
  if(n%%1!=0){stop("invalid arguments")}
  #declaring objects for later use:
  n.numbers <- 0
  final <- vector()
  U <- NULL
  #starting the repeat loop that controls the length of the output (n):
  repeat{
    #starting the repeat loop that checks whether the rejection condition is met:
    repeat{
      #starting the for loop to create random uniform numbers:
      for(i in 1:2){
        U[i]<- runif(1,0,1)
        U[i]<-2*U[i]-1
      }
      w<-U[1]^2+U[2]^2
      if(w<=1){
        v <- sqrt((-2*log(w))/w)
        prelim <- NULL
        Res <- NULL
        #Starting the for loop to adjust the standard normally distributed numbers to specific distributions
        for(i in 1:2){
          prelim[i]<- U[i]*v
          Res[i]<-(prelim[i]*sd)+mean
        }
        final <- c(final,Res)
        break
      }
    }
    #breaking the loop as soon as n (or n+1 if odd number) numbers have been generated
    if(n.numbers==(n_new/2)-1) break
    n.numbers <- n.numbers+1
  }
  #restricting the number of the output to the required length:
  length(final) <- n
  return(final)
}

#my.rnorm(100,1,1)

#************************************TESTING************************************
#Normality of results:
is.my.rnorm.normal <- function(mean=0, sd=1, n=100){
##Purpose: Test my.rnorm for normality
##Input: mean, standarddeviation and number of deviates to be generated by the function
##Output: Results of Shapiro-Wil test, QQ-Plot, Histogram of values generated by my.rnorm and density of rnorm
  
  #Constraint due to Shapiro test:
  if(n<=3){stop("Please use n > 3 for meaningful results")}   
  
  #1.Checking out the Shapiro-Wilk test; H0: x ~ N(m,sd) H1: x !~ N(m,sd) -> if p>alpha do not reject H0
  p.value <- shapiro.test(my.rnorm(sd=sd,mean=mean, n=n))$p.value
  if(p.value>0.05){cat("Shapiro-Wilk test passed with a p-value of:", p.value, "\n")
  }else{cat("Shapiro-Wilk test failed with a p-value of:", p.value, "\n")}
  
  #2. Let's check out some graphs:
  par("mfrow"=c(1,2))
  qqnorm(my.rnorm(sd=sd,mean=mean, n=n))
  histogram <- hist(my.rnorm(sd=sd, mean=mean, n=n), col="lightblue", main="Histogram of my.rnorm, density of rnorm")
  multiplier <- histogram$counts / histogram$density
  hist.density <- density(rnorm(10000000,mean=mean,sd=sd))
  hist.density$y <- hist.density$y * multiplier[1]
  lines(hist.density, col="red",lty=3)
  
  #3. And finally see how we do with the tail property of normal distributions:
  ##didn't work
}


#is.my.rnorm.normal(mean=100, sd=15,n=1000)


## ---------------- Algorithm for chisquared-distributed deviates ----------------
my.rchisq <- function(n, df=1){
##Purpose: Generate pseudo-random chisquared distributed deviates
##Input: n as in the number of pesudo-random deviates, df as the degrees of freedom
##Output: vector including pseudo-random chisquared distributed deviates
  
  #Checking for plausibility of arguments first:
  if(missing(n)){stop("invalid arguments")}
  if(is.complex(n) | is.complex(df)){stop("invalid arguments")}
  if(!is.numeric(n) | !is.numeric(df)){stop("invalid arguments")}
  if(n<=0){stop("invalid arguments")}
  if(df<=0){stop("invalid arguments")}
  if(is.complex(n)|is.complex(df)){stop("invalid arguments")}
  if(n%%1!=0){stop("invalid arguments")}
  if(df%%1!=0){stop("invalid arguments")}
  #declaring objects used further down:
  n.chinumbers <- 0
  final <- NULL
  #initiating the loop to calcualte chisquared deviates
  repeat{
    Z <- my.rnorm(sd=1,mean=0,n=df)
    Z<- Z^2
    chisquare <- sum(Z)
    final <- c(final,chisquare)
    if(n.chinumbers==(n-1)) break
    n.chinumbers<-n.chinumbers+1
  }
  return(final)
}

#my.rchisq(100,4)

#************************************TESTING************************************
#Chisquare distribution of results:

is.my.rchisq.chisq <- function(n=100, df=1){
##Purpose:check, whether my.rchisq generates rchisq distributed values
##Input: n number of values with df degrees of freedom
##Output: Histogram, chisquare distributed density, cumulative density function, K-S Test, Shapiro-Wilk Test
  
  #constraint due to shapiro test:
  if(n<=3){stop("Please use n > 3 for meaningful results")}
  #1. Two-sample K-S Test: see whether both H0: both samples drawn from the same continous sample
  #Getting the p-value
  ks.p <- ks.test(my.rchisq(n=n,df=df), rchisq(n=n,df=df))$p.value
  #Interpreting the p-value:
  if(ks.p>0.05){cat("Two-Sample Kolmogorov-Smirnoff-Test:","\n", "With a p-value of ",ks.p," the H0 is not rejected: It can be estimated, that both samples are from the same continous distribution. ","alpha=0.05","\n")
  }else{cat("Two-Sample Kolmogorov-Smirnoff-Test:", "\n", "With a p-value of ",ks.p," the H0 is not rejected: It can be estimated, that both samples are from the same continous distribution. ","\n")}
  
  
  #2. Checking out graphs
  #Histogram
  par("mfrow"=c(1,2))
  histogram <- hist(my.rchisq(n=n, df=df), col="lightblue", main="Histogram of my.rchisq, density of rchisq")
  multiplier <- histogram$counts / histogram$density
  hist.density <- density(rchisq(10000000,df=df))
  hist.density$y <- hist.density$y * multiplier[1]
  lines(hist.density, col="red",lty=3)
  #Cumulative distribution function
  plot(ecdf(my.rchisq(n=n, df=df)), col="coral")
  lines(ecdf(rchisq(n=n, df=df)), col="darkgrey")
  
  #3. Checking for the asymptotic property:
  #for small df:
  p.value_small <- shapiro.test(my.rchisq(n=n, df=1))$p.value
  if(p.value_small>0.05){cat("\n","With df=1 the Shapiro-Wilk test is passed with a p-value of:", p.value_small, "\n")
  }else{cat("With df=1 the Shapiro-Wilk test failed with a p-value of:", p.value_small, "\n")}
  #for large df:
  p.value_big <- shapiro.test(my.rchisq(n=n, df=100))$p.value
  if(p.value_big>0.05){cat("With df=100 the Shapiro-Wilk test is passed with a p-value of:", p.value_big, "\n")
  }else{cat("With 100 df the Shapiro-Wilk test failed with a p-value of:", p.value_big, "\n")}
  #conclusion:
  if(p.value_small<0.05 & p.value_big>0.05){cat("\n","The distribution approaches a normal distribution as df -> inf:", "\n", "This means that the asymptotic property of the chisqaure distribution holds and indicates Chisquare distributed values", "\n")
  }else{cat("The distribution does not approach a normal distribution as df -> inf:", "\n", "This indicates non-chisquare-distributed values")}
  
}

#is.my.rchisq.chisq(n=100, df=80)


##---------------- Algorithm for random t distributed deviates  ----------------
my.rt <- function(n, df=1){
  ##Purpose: generating pseudo-random t-distributed deviates
  ##Input: n as in the number of deviates produced, df as in the degrees of freedom
  ##Output: a vector with n random t-distributed values
  
  #Checking plausibility of arguments:
  if(is.complex(n) | is.complex(df)){stop("invalid arguments")}
  if(!is.numeric(n) | !is.numeric(df)){stop("invalid arguments")}
  if(missing(n)){stop("invalid arguments")}
  if(n<=0){stop("invalid arguments")}
  if(df<=0){stop("invalid arguments")}
  if(is.complex(n)|is.complex(df)){stop("invalid arguments")}
  if(n%%1!=0){stop("invalid arguments")}
  if(df%%1!=0){stop("invalid arguments")}
  #declaring objects used further down:
  n.tnumbers <- 0  
  #initiating the repeat loop to control the number of deviates generated:
  repeat{
    Z <- my.rnorm(sd=1,mean=0,n)
    U <- my.rchisq(n=n, df=df)
    t <- (Z/(sqrt(U/df)))
    if(n.tnumbers==(n-1)) break
    n.tnumbers<-n.tnumbers+1
  }
  return(t)
}

#my.rt(100,1)

#************************************TESTING************************************
#t-distribution of results:

is.my.rt.t <- function(n=100, df=1){
  ##Purpose: Testing wether the results of the function my.rt are t-distributed
  ##Input: n as in the amount of values to produce, df as in the degrees of freedom
  ##Output: Hisogram for the output of my.rt and the density of rt(), Shapiro-Wilk test results and conclusions
  
  #Constraint due to Shapiro test:
  if(n<=3){stop("Please use n > 3 for meaningful results")}
  #1. T-distribution approaches Normal distribution as df -> inf
  #for small df:
  p.value_small <- shapiro.test(my.rt(n=n, df=1))$p.value
  if(p.value_small>0.05){cat("With df=5 the Shapiro-Wilk test is passed with a p-value of:", p.value_small, "\n")
  }else{cat("With df=1 the Shapiro-Wilk test failed with a p-value of:", p.value_small, "\n")}
  #for large df:
  p.value_big <- shapiro.test(my.rt(n=n, df=100))$p.value
  if(p.value_big>0.05){cat("With df=100 the Shapiro-Wilk test is passed with a p-value of:", p.value_big, "\n")
  }else{cat("With 100 df the Shapiro-Wilk test failed with a p-value of:", p.value_big, "\n")}
  #conclusion:
  if(p.value_small<0.05 & p.value_big>0.05){cat("The distribution approaches a normal distribution as df -> inf:", "\n", "This indicates t-distributed values", "\n")
  }else{cat("The distribution does not approach a normal distribution as df -> inf:", "\n", "This indicates non-t-distributed values")}
  
  #2. Looking at a hist:
  par("mfrow"=c(1,2))
    #Histogram of my.rt with df degrees of freedom
    histogram <- hist(my.rt(n=n, df=df), col="lightblue", main="Histogram of my.rt, density of rt")
    multiplier <- histogram$counts / histogram$density
    hist.density <- density(rt(10000000,df=df))
    hist.density$y <- hist.density$y * multiplier[1]
    lines(hist.density, col="red",lty=3)
    
    #Histogram of my.rt wit df=100 
    histogram_df <- hist(my.rt(n=n, df=100), col="lightblue", main="Histogram of my.rt with df=100, density of rt")
    multiplier_df <- histogram_df$counts / histogram_df$density
    hist.density_df <- density(rt(10000000,df=100))
    hist.density_df$y <- hist.density_df$y * multiplier_df[1]
    lines(hist.density_df, col="red",lty=3)
}

#is.my.rt.t(n=50, df=10)

